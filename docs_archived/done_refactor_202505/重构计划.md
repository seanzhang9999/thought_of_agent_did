### **关于开发 ANP 双向 DID 认证及架构优化的技术提案**

**提案日期:** 2025年6月11日
**提案人:** [seanzhang9999@gmail.com]
**版本:** 1.0

---

### 1. **核心目标**

为解决当前 ANP (应用网络协议) 中 DID 认证机制的单向认证安全风险、代码架构耦合度高以及 DID 方法扩展性不足等问题，本次技术升级旨在：

1. 引入  **双向 DID 认证机制** ，确保客户端与服务器之间的双向信任和通信安全。
2. 重构认证逻辑，引入 **`LocalAgent`** 和  **用户数据类** ，实现核心逻辑与数据访问的解耦。
3. 抽象  **DID 基类** ，实现通用 DID 操作的封装，为未来适配多种 DID 方法提供灵活性。

---

### 2. **需求背景与问题分析**

#### 2.1. 单向认证的安全隐患

当前 ANP 的 DID 认证是单向的： **客户端向服务器证明“我是谁”** 。

* **流程:** 客户端发起请求 -> 服务器验证客户端 DID -> 认证成功后返回数据（可选下发 Token）。
* **缺陷:** 服务器无法向客户端证明其身份的合法性。
  * **公网风险:** 即使采用 HTTPS，依赖于证书信任链和配置的正确性，仍可能因证书泄露、CA 被攻破或用户信任了伪造证书而遭受中间人攻击，攻击者可冒充服务器截获或篡改通信内容。
  * **内网风险:** 内网环境下，通常缺乏权威 CA 签发的可信 HTTPS 证书，客户端很难有效验证服务器身份，极易误连到恶意或未授权服务器，导致数据泄露、篡改等严重安全隐患。
。

**双向认证的必要性:**
通过引入双向认证，客户端在验证服务器身份后才与之进行后续通信，建立双向信任链。这不仅能有效防范中间人攻击，还能在此基础上轻松加入 **端到端加密** 机制，即使在复杂的网络环境（如经过多层反向代理）下，也能保证通信链路的机密性和完整性。

#### 2.2. 现有代码架构的局限性

当前认证库的代码实现存在以下问题：

* **硬编码与高耦合:** 无论是服务器端解析 DID、访问 DID 文档、加载 JWT 私钥，还是客户端加载 DID 私钥，都依赖于硬编码的路径或写死的逻辑。这使得代码难以维护、测试和迁移。
* **逻辑与数据混杂:** 认证流程（做什么）与数据获取（从哪里拿数据）的逻辑紧密耦合，导致核心认证代码不够纯粹，难以复用和扩展。

#### 2.3. DID 方法扩展性不足

现有实现针对的是特定的 DID 方法。如果未来需要支持新的 DID 方法（如 `did:ion`, `did:key` 等），就需要对现有代码进行大规模修改，缺乏灵活性和可扩展性。

---

### 3. **技术方案与实施路径**

为解决上述问题，我们提出以下三项核心改进措施：

#### 3.1. **引入双向 DID 认证机制 (Mutual DID Authentication) 及流程优化** 🤝

我们将设计并实现一个双向认证流程，并对流程做如下优化和兼容性设计：

**核心流程:**

1. **客户端发起连接（生成 Nonce）:**
   客户端用自身 DID 私钥对 Nonce 及相关信息签名，连同客户端 DID 标识一并发送给服务器。
   客户端在发起初始请求时，**直接生成一个随机 Nonce**，并将其作为认证请求的一部分发送给服务器。这样可以节省一次往返请求，提高认证效率。为防止重放攻击，服务器需维护已用 Nonce 的黑名单或时间窗，拒绝重复使用的 Nonce，并设计相应机制保证安全。

2. **服务器响应与双向认证:**
   服务器收到请求后，服务器解析客户端 DID 标识，获取公钥，验证签名。使用自身 DID 私钥对客户端发来的 Nonce 进行签名，并将签名、Nonce、服务器的 DID 标识，以及（如适用）Token 一并返回。
   **注意：**服务器返回的认证结构应与客户端发送的结构保持一致，便于客户端对服务器身份进行验证，实现真正的双向认证。
3. **客户端认证服务器:**
   客户端解析服务器返回的 DID 标识，获取其 DID 文档和公钥，验证服务器签名的有效性。

**兼容性与错误处理机制：**

- 客户端需支持对服务器返回结果的多种情况进行判断和兼容处理：
  1. **401 状态码**：表示认证失败，需终止流程并提示用户。
  2. **401 以外的错误**：表示认证已通过，但请求出现其他问题，应视为认证成功，直接透传返回内容给上层调用。
  3. **认证成功返回的三种情况**，需在认证后将认证类型标识返回给调用代码：
     - **Bearer Token**：第一代单向认证，存储 Token。
     - **Token + 双向认证数据**：第二代双向认证，需验证服务器 DID 后存储 Token。
     - **无任何数据**：第一代仅支持 DID 认证、不使用 Token 的服务器，不做额外处理。

- 服务器端同样需通过解析认证信息的结构，判断请求方采用的是第一代还是第二代认证，或根据认证信息中的方式标识，选择合适的认证与响应内容生成逻辑。

- **所有认证信息均通过 HTTP Header 的 Authorization 字段进行传递**，以提升网络环境的适应性和兼容性。

#### 3.2. **架构重构：引入 `LocalAgent` 与数据抽象层** 🏗️

我们将对认证代码的逻辑体系进行重构，实现关注点分离。

* **用户数据类 (UserData Class):**
  * **定义:** 这是一个抽象的数据访问层。
  * **职责:** 负责处理所有与“本地数据”相关的操作，例如从文件系统、数据库或环境变量中读取/写入 DID 私钥、JWT 密钥、Token 等。
  * **优势:** 将数据存储的细节与核心业务逻辑解耦。未来若需改变存储方式（如从本地文件改为数据库），只需实现一个新的用户数据类即可，无需改动上层代码。
* **智能体 (`LocalAgent`):**
  * **定义:** 作为一个中心协调器对象。
  * **职责:**
    * **管理用户数据:** 持有并调用用户数据类的实例，获取所需密钥和配置。
    * **协调认证行为:** 在客户端，`LocalAgent` 负责发起认证、管理 Token 的获取、保存和使用。在服务器端，`LocalAgent` 负责验证客户端、生成 Token 等。
    * **封装复杂性:** 将双向认证的复杂流程封装在 `LocalAgent` 的方法调用中，为上层应用提供简洁的 API。
  * **扩展设想：ContactManager 组件**
    * **定义:** 在 `LocalAgent` 内部新增 `ContactManager` 组件，用于统一管理所有已知的 `RemoteAgent` 及其相关数据。
    * **主要功能:**
      - **RemoteAgent 数据管理:** 维护所有远程智能体（RemoteAgent）的信息，初期主要包括认证 Token，未来可扩展为包括认证方式、连接参数、证书信息等。
      - **接口设计:** 提供添加、删除、查找、更新 RemoteAgent 的标准接口，便于上层逻辑调用和维护。
      - **安全性:** 统一管理 Token 和认证信息，有助于提升系统整体的安全性和可追溯性。
    * **未来扩展:** ContactManager 可根据实际需求，集成更多与认证和连接相关的元数据（如信任等级、连接历史、DID 文档缓存、anp_tool爬取结果等），为多智能体协作和网络拓扑管理提供基础能力。

`上层应用 -> 调用 LocalAgent -> LocalAgent 调用 DID 基类进行密码学操作 -> LocalAgent 通过用户数据类获取/保存密钥或 Token -> LocalAgent 通过 ContactManager 管理所有 RemoteAgent 的认证和连接信息`
**新架构的逻辑流:**

#### 3.3. **封装通用 DID 基类 (DID Base Class)** 🧬

为了支持多种 DID 方法并简化 `LocalAgent` 中的逻辑，我们将创建一个 `DID` 基类。

* **职责:**
  * **DID 标识解析 (DID Parsing):** 提供解析 `did:method:identifier` 字符串的标准方法。
  * **认证结构封装:** 定义标准的质询/应答数据结构，并提供生成和验证这些结构的方法。
  * **密码学操作抽象:** 封装签名和验签等核心密码学行为，子类可以根据不同的 DID 方法（如使用不同加密套件）进行具体实现。
* **实现:**
  * 在 `LocalAgent` 的实现中，将使用这个 `DID` 基类来处理所有与 DID 相关的操作。
  * 未来需要支持新的 DID 方法时，只需继承该基类，实现其特定的解析和密码学逻辑即可无缝接入现有认证体系。

---

### 4. **预期收益**

* **安全性显著提升:** 双向认证机制将彻底解决服务器身份伪造的风险，尤其能保障内网环境的通信安全。
* **代码质量与可维护性提高:** 通过引入 `LocalAgent` 和数据抽象层，代码结构将变得更加清晰、模块化，易于维护和扩展。
* **灵活性与未来适应性:** DID 基类的设计使得系统能够快速、低成本地适配未来的新型 DID 标准和技术。

* **开发效率提升:** 封装后的 `LocalAgent` 将为应用层开发者提供更加简洁、易用的接口，降低集成难度。
